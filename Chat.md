# 拿这个记录吧
### 1 命令行  
- 命令行快捷键：Ctrl + ` (Nice)
- 查看当前目录指令pwd（坡屋顶）
- 在Cmder里面默认给显示了全路径绿色这个
- cd 指令改变目录
- ls 列出当前文件夹
- ......

---

### 2 Git
- 2.0 Git有远程仓库和本地仓库之分
- 2.1 查看当前Git仓库状态，像是在清点库存
    ```
        git status
    ```

- 2.2 克隆远程仓库，将远程仓库抓到本地，叫克隆的原因是，你这个操作不会影响远程仓库
    ```
        git clone https://github.com/username/xxx.git
    ```

- 2.3 追踪文件，新添加的文件需要被Git追踪之后，才会参与到整个大项目中来，就像是你往仓库订货，货送过来了，放在门口，你需要清点一下都有啥一样，不清点，不入库
    ```
        git add filename
        git add .
    ```
    第二行是一次性添加所有未追踪文件，执行这个操作的时候，需要先运行 git status查看都有谁未被追踪

- 2.4 清点完之后需要搬到仓库里放着对吧，这个操作叫做提交
    ```
        git commit filename -m "提交指定文件的信息记录"
        或者
        git commit -a -m "这个操作一下提交所有追踪过的文件"
    ```

- 2.5 搬到货架上还没完，因为你家的仓库很高级，会将所有的库存信息上传到云端，以便查询，店里的所有员工都可以查询，或者更改，并且每一次更改都能追究到个人身上，丢东西了，或者别打问题都能很好的解决，这一步操作叫做推送
    ```
        git push -u origin master
    ```
    origin 代表远程仓库 master是主分支，默认有一个主分支

- 2.6 因为你家的仓库不止一个，全国各地都有，所有的仓库库存信息都是放在一起的，你想知道鞋子有多少双，你得先同步一下数据对吧！这个地方其实会有几种操作，一个是
    ```
        git pull
    ```

    ```
        git fetch
        git merge
    ```
你在右手边哪个控制台试，我就能看到你的控制台
Git这块暂时说到这里把，有什么问题吗？我先操作一下试试

等一下，你的路径错了阿
你看你先在在E盘cmder下面
no no这波不对，你开错文件夹了
我整明白了
你在本地搞了两个仓库
所以你上一次的提交没有提交上去先在这个仓库提交一遍把，然后去那个仓库抓下来

看这边！！！！！！！！！！


好的，没事儿，不要心急，不要着急
我知道问题在哪儿了

你现在的工作目录在cmder下

你的D盘里的Code应该也有内容，不如这样，都删了，再搞一遍
我team你



e 应该是错的 不小心给clone下来了
这个狗好像你滚蛋
哈哈哈

刚才那样不要慌
下把注意工作目录就好
不然你写的代码都不知道去哪儿了
我提交一遍给你看

首先，查看仓库状态,两个修改过的文件，一个未追踪文件
未最终文件就是当前编辑的这个，咱们不需要，就不追踪了

然后，就是点货对吧，但是，未点过货的之后现在编辑这个文件，所以不用点货

再后，就是刚才检查完仓库状态发现有两个文件被修改了，那就应该提交，提交需要些提交信息

现在虽然工作区不干净，就是没有显示那个Work Tree Clean

但是这个Chat.md是咱们自愿不参加GIt工作流的所以可以push了


# Processing

目标是36行代码全部理解
短期目标，是这36行代码全部理解，并且默写


首先，Processing很简单
CAD画线会不
Grasshoper画线会不
是不是都很简单
画线就输入画线的指令 
然后指定两个点对吧，
就可以得到直线
界面很简单
三个按钮
前两个是运行和停止
后面是Debug
然后就是编辑器
这个是可以直接运行的
刚才那个小窗口就是默认结果
100像素见方的画板
画了一条直线
左上角到右下角


就像是Grasshopper里画一条线一样
拽一个line运算器，然后给两个点

这里的是line（）函数

需要载入4个参数

line(x1,y1,x2,y2);

两个点（x1，y1）（x2，y2
）ok

我是想和你说明，一种函数思想

就是，函数是黑匣子

line这个函数，是画线用的，需要输入四个参数，然后得到一条直线
他是个内置算法呗 嗯嗯其实跟gh原理是类似的对，应该叫函数或者方法
这么叫比较专业ok

以后我说的p5就代表processing

刚才说了，p5默认给创建了100见方的画板
需要改怎么办？
刚才打成句号了
size(width,height);//这个函数是设置当前草图的画布大小，在第三个参数未指定的情况下，采用默认值
这个size还有另一种写法
size(width,height,render)//render是指定渲染器默认值是P2D

然后在Processing编辑器里面，可以直接查询函数帮助文档

能跟上不？ojbk

刚才说了函数的输入值和返回值

然而size（）函数返回值是void
line（）的也一样

下面解释void是什么

要想理解void，得先从函数的定义开始
函数是指为了实现某一些功能的集合
将某一种功能，写成函数，就可以模块化代码，方便使用，复用
这里说的功能就比如说是，画线，画圈，画方啥的
同样的，你也可以自己写函数，而且你写的函数里还可以调用别的函数，这样一来既方便使用，又能写出相当复杂的程序，还好维护。


三要素:参数，过程，返回
参数就是输入给这个过程的值
过程就是你的一些操作
返回就是经过你打操作，希望这个函数返回的值，如果不反悔，就是返回为空即void

那也就是说 line是个过程
可以这么说，其实line的返回值已经在屏幕显示了，视觉反馈，所以没有值，对，没有返回值

一般来讲，返回值是需要用来参与下一步计算的

ok

void其实是一种数据类型

同样的，还有别的 类型，当我需要有返回值的时候，需要先指定返回值是什么类型

比如整数int
单精度浮点小数float
布尔值boolean
等等
现在先知道前两个就行

第一个就是1,2,3,4,5,6,7，-1,3， -6， -100， 100这样子的整数
还记得实数不？有点印象就是R，也就是带小数点的，pi就是实数，小数点后无限位，这里的单精度浮点小数float虽然只能描述有限个实数，但是够用了，在没有需要精确到一个很精确的范围为的时候，是够用的

f(x) = 2x (x为实数)  看着眼熟不？是和虚数相对的吗好像是我知道虚数...i，嗯嗯没事，够用

这个f(x) = 2x就是一个函数，数学里的函数
f(1) = 2
f(2) = 4
.
.
.
.

你来描述一下这个函数的功能是什么，把三要素说出来？
参数x 过程x乘以2 返回值2x
不对
需要再详细一点
参数是一个 实数x  过程是将这个实数乘以2  返回值刚才过程的结果并是个实数Soga

在p5以及在其他编程语言中，一般是用float代表实数集
想再精确一点就双精度，叫做double

然后我告诉你定义一个函数的写法：

返回类型 函数名（参数类型 参数名）{
    变量类型 过程变量名 = 某种操作；
    return 过程变量名；
}

假设这个函数名字叫fanbei，请写出这个函数？

float fanbei(float x) {
    float y = x*2;
    return y;
}

两个问题
1.每一句结束需要分号，花括号不用
2.变量名不能以数字开头，变量名不能重复


刚才你已经自己写了一个函数了

下面介绍两个新函数
一个setup（）一个draw（）

这俩返回值为空，输入值为空，是两个特殊的函数，是供用户重写的函数
下面我们来重写一下这两个函数

这就是重写了
这就是这36行代码的结果
看起来咋样666
哈哈哈
可以有鼠标互动，你试试骚的一批


我可以很负责任的说，这36行代码你全都整明白的话，processing基础也就吃透了
我把基础语法全穿在一起写的这个总共才36行

下周这时候之前有没有信心整明白？木问题！最不缺的就是信心哈哈哈哈

那我开始讲了ok

用TAB建

processing 2d渲染
```Java
/*
*这个是多行的
嗯呢，随便玩
可以换行
*/
不定义函数也可以定义变量呗？
对，看来这一步我讲调了，录课的时候我得注意 就是说我这个顺序可以不一样 是不是，不是，你不用在意这些细节，是我忘记讲了，应该先讲定义变量，再讲定义函数ok


定义变量：
第一种---定义不初始化：
float a;
//过了一些操作之后也可以再初始化这个
.............
..........
a = 0.5;
第二种----定义就初始化
float b = 0.3;//定义一个单精度浮点变量b，并且初始化，初始值为0.3
ok

还有一种东西叫做系统变量，比如这个PI

就是π的值
//这个叫注释，你操作一下试试
float t = PI;//定义一个单精度浮点变量t，并且初始化，初始值为PI
int times = 0;
在介绍一个函数
print()//不换行打印
println()//换行打印
能看懂不这个能

接下来介绍p5的核心，精华部分

看明白这是什么意思没？我想一下 为什么会重复drow

你看懂了
p5 的精华就是

setup()只运行一次
draw()无休止死循环

这是p5的天分，生下来就这样，
下面我来和你解释这个是啥意思

在这之前，先介绍另两个环境变量
mouseX
mouseY
分别指向当前鼠标的坐标恩恩额
对了，坐标系忘了和你说
和平面直角坐标系不一样
拿起你的左手，对着屏幕，食指指向屏幕下边缘，拇指指向屏幕右边缘，抬起中指

食指是Y正方向
拇指是X正方向
中指是Z正方向

get？一样的，啊俯视嘛，反正记住就行，忘了的时候抬起左手

刚才说了，画直线的，现在说个画圈的

p5立面没有画圆的，只有画椭圆的，和Ai里的是一个意思

长短轴相等就是圆

ellipse(x,y,w,h);
x，y是圆心坐标
w，h是宽高

下面开始解释p5 的精华就是

能理解这个是什么意思不 能 行，那你自己把这些内容先消化一下吧， ok今天就到这了ok

明天你抽空和我说，这个setup（）和draw（）的意义
先捂一下吧

你和我老实说，因为这将是我课程的内容，我是拿我课件给讲的，有有问题的话我及时更正，就像刚才那个变量忘了说一样 等一下我先想两分钟嗯嗯

感觉咋样，能不能听懂 可以的  

你运行吧
float t = PI;//定义一个单精度浮点变量t，并且初始化，初始值为PI
int times = 0;
void setup(){
   size(800,800);
   noStroke();
   smooth();
}


void draw(){
   fill(50 * sin(t),(mouseX < width/2) ? 300 : 50);
   rect(0,0,width,height);
   int s;
   switch(times % 3){//相当于开关
     default : s = 3;break;
     case 1 : s = 4;break;
     case 2 : s = 5;break;
   }
   if(s == 5) s = -s;
   translate(width/2,height/2);//改变坐标原点
   fill(200+10*cos(t));
   rotate(2*t/s);
   float[] args = {abs(s),abs(s)/sin(t),mouseX/50.0,mouseX/50.0};
   for(float a = 0; a < TWO_PI; a+=PI/30){
      float R = superFormula(a,args);
      ellipse(180 * R * cos(a),180 * R * sin(a),3,3);
   }
   while(t <= 0){
     t=PI;
     times+=1;
   }
   t-=0.03;
}


float superFormula(float a ,float[] args){
   float m = args[0];float n1 = args[1];
   float n2 = args[2];float n3 = args[3];
   return pow((pow(abs(cos(m*a/4)),n2) + pow(abs(sin(m*a/4)),n3)),-1/n1);
}
```

下面开始一些简单的动画示范
帧，这个概念需要我解释吗？应该不用吧ok
时间，用一个全局变量来代表这个程序运行的时间一个浮点数
一直增长

这个看起来熟悉吧！en 
然后我们用这个t来当作画圆的一个参数
好的，这就是第一个动画
跟上？ok
刚才也看到了，圆走过的轨迹都被保留下来，现在我们在draw的开头画一遍背景，意味着每一次draw每一帧都先画一遍背景，相当于将之前的内容全部抹掉
这里用204的原因是，p5的默认值是204
如果直接设置为黑色将会闪一下，好吧，电脑上运行很快，几乎察觉不到第一帧背景不是黑色

啥都没出现，是因为在第七行设置了fill，第9行没有设置回来，所以画图的内容和背景色一样了，就啥都没有来


能不能看出来fill的第二个参数是干嘛的？感觉像延时？不是是透明度
就是每帧我用一个带
透明度的橡皮去擦，会留下一些轨迹，值越小背景透明越多

你按一下ctrl +号再大点

Nice

继续，

我们现在来画一个经典的loading动画，就是一堆圈在转
现在这一步for是为了细分360度为num份然后存到pts中

这个地方犯了经典的错误，试图将float塞到PVector的数组中，这样子是不允许的


在这里需要写一个函数c
输入参数是angles 里的角度
返回的是一个PVector 这里用PVector原因是他能带上x和y
整吧，写个函数！先把细分的圆画出来
听明白啦不这个函数的功能en
你可能需要草算纸计算计算

首先，PVector是一种变量，能理解哈，和float int一样都是变量，只不过，这个变量能储存两个值算上z的话能存3个值，

float a = 1.5;
float b//声明一个float
b = 2.4;//为这个b赋予初始值

PVector p;//声明一个PVector
p = (0,5);//这一行是为变量p赋予一个初始值，等号右边和前面变量b的等号右边是一样的，就是书写规则是这样而已，这样能理解吗
我理解这个PVector嗯嗯

18行这里

是常用的编程思想，
就是首先我需要一个点的坐标，来确定当前要画的圆的位置对吧，然后我当前拥有的只有一系列的角度，也就是说，我要在一个大圆轨迹上细分为num份，然后要得到这些细分点点坐标，我现在能提供的只是角度等下
我先说完，我现在有的是角度位置，但是我需要的是一个PVector
这时候，就假设我有一个函数，这个函数输入的是我的角度，输出的是点，那这个主程序的思路就不会被打断，补上一个实现这个功能的函数即可，这里是假设法，很方便的那种思路连贯说完了，你说你的
PVector定义的函数形式是不是PVector（f（a），g（a））no
当然不是，
回忆一下
函数的定义

返回类型 函数名（载入参数）｛
一些操作之后
如果返回类型非空，就return一个与所定义返回类型相符合的变量
｝

刚才说了，PVector是一种类型
和 float int是一样的
所以，这个函数形式应该是什么样？
PVector c（float angle）{
    float r = 300;
    float _x = r * cos(angle);
    float _y = r * sin(angle)
    PVector p = new Pvector(_x,_y);
    return _p;
}
跟上不？等下我想一下

对的 我基本上理解了
嗯嗯
运行一次试试 刚才确实掉到PVector这个坑里了 想不明白它定义出来是什么形式

Pvector这个事儿等我给你讲面对对象编程你就知道了


运行结果有点奇怪哈，我给你解释

首先是坐标，然后半径超过画布，然后没有等分，没有等分这个很关键了，因为我们输入的是角度，而p5默认是以弧度运算，所以转换一下

沒毛病老鉄
目前爲止get了嗎ok了

好的繼續，如何然他動起來，
這一步方法很多，
可以直接旋轉
乱跑了
中心点不对
怎么样get了吗ok
这么旋转是最快的方法
还有一种是通过定义每一个园动态的半径，只要和t发生关系就行，只不过没有这个来得快

再开一下脑洞

如果有好几环的这个玩意在转会是啥样
你这个死机了，保存一下
在打开吧
